<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>一文了解 Go 语言 Sync 标准库 | 谈笑风生间</title><meta name="author" content="谈笑风生间"><meta name="copyright" content="谈笑风生间"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面Go 语言是一门在语言层面支持用户级线程的高级语言，因此并发同步在 Go 程序编写中尤其重要，其中 channel 虽然作为并发控制的高级抽象，但它的底层就是依赖于 sync 标准库中的 mutex 来实现的，因此了解 sync 标准库是每一个 Gopher 的必备技能之一。 笔者使用的 Go 版本是 1.18.1 sync.WaitGroupsync.WaitGroup 使得多个并发执行">
<meta property="og:type" content="article">
<meta property="og:title" content="一文了解 Go 语言 Sync 标准库">
<meta property="og:url" content="https://makonike.github.io/2023/01/29/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Sync%E6%A0%87%E5%87%86%E5%BA%93/index.html">
<meta property="og:site_name" content="谈笑风生间">
<meta property="og:description" content="写在前面Go 语言是一门在语言层面支持用户级线程的高级语言，因此并发同步在 Go 程序编写中尤其重要，其中 channel 虽然作为并发控制的高级抽象，但它的底层就是依赖于 sync 标准库中的 mutex 来实现的，因此了解 sync 标准库是每一个 Gopher 的必备技能之一。 笔者使用的 Go 版本是 1.18.1 sync.WaitGroupsync.WaitGroup 使得多个并发执行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/title.jpg">
<meta property="article:published_time" content="2023-01-29T09:01:31.000Z">
<meta property="article:modified_time" content="2023-03-30T16:51:02.614Z">
<meta property="article:author" content="谈笑风生间">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="标准库">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="网络">
<meta property="article:tag" content="sync">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/title.jpg"><link rel="shortcut icon" href="https://i.loli.net/2021/10/03/N9cpBZe75b2tQfz.png"><link rel="canonical" href="https://makonike.github.io/2023/01/29/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Sync%E6%A0%87%E5%87%86%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '一文了解 Go 语言 Sync 标准库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-31 00:51:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/title/avatar1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/title.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="谈笑风生间"><span class="site-name">谈笑风生间</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">一文了解 Go 语言 Sync 标准库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-29T09:01:31.000Z" title="发表于 2023-01-29 17:01:31">2023-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-30T16:51:02.614Z" title="更新于 2023-03-31 00:51:02">2023-03-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%80%E6%96%87%E7%B3%BB%E5%88%97/">一文系列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/">学习日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="一文了解 Go 语言 Sync 标准库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Go 语言是一门在语言层面支持用户级线程的高级语言，因此并发同步在 Go 程序编写中尤其重要，其中 channel 虽然作为并发控制的高级抽象，但它的底层就是依赖于 sync 标准库中的 mutex 来实现的，因此了解 sync 标准库是每一个 Gopher 的必备技能之一。</p>
<p>笔者使用的 Go 版本是 1.18.1</p>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>sync.WaitGroup 使得多个并发执行的代码块在达到 WaitGroup 显式指定的同步条件后才得以继续执行<code>Wait()</code>调用后的代码，即达到并发 goroutine 执行屏障的效果。</p>
<p>在以下代码中，我们希望达到多个 goroutine 异步执行完输出任务后，main goroutine 才退出的效果，此时程序执行完毕。转换为实例，就是使得程序输出 110，此处我们并不关心<code>main()</code>中创建的两个 goroutine 之间的执行顺序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Print(<span class="number">1</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Print(<span class="number">1</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Print(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>与期望结果不符，程序运行完毕时只输出了 0，这是因为 goroutine 的创建和调度需要时间，在两个 goroutine 创建期间，main goroutine 已经输出了 0，导致 main 函数结束，程序执行完毕。我们可以使用 WaitGroup 来完成上述需求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      fmt.Print(<span class="number">1</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      fmt.Print(<span class="number">1</span>)</span><br><span class="line">   &#125;()</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Print(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出 110</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110</span><br></pre></td></tr></table></figure>

<p><code>sync.WaitGroup</code>中记录了仍在并发执行的代码块的数量，<code>Add()</code>相当于对这个数量执行 +1 操作，不难想到<code>Done()</code>则为执行了<code>Add(-1)</code>，事实确实如此。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done decrements the WaitGroup counter by one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">   wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>在此之前，我们先明确设定<strong>状态</strong>为<strong>运行计数与等待计数</strong>，<strong>信号</strong>为<strong>信号计数</strong>。</p>
<p>WaitGroup 的结构体记录了运行计数，等待计数和信号计数三个 uint32 来对并发的 goroutine 进行不同目的的计数，在笔者使用版本中，其实是一个 uint64 与一个 uint32。这里兼容了 32 位系统，因为在<strong>32 位机器上无法实现对 64 位字段的原子操作</strong>（64 位字段相当于两个指令，无法同时完成）。在 32 位平台上，如果<code>wg.state1</code>元素依然按照 64 位平台的顺序返回（waiter, counter, sema），那么<code>wg.state1[0]</code>的内存地址是 32 位对齐的，不能保证一定是 64 位对齐的，就无法进行 64 位原子操作（后续需要对状态进行整体的原子更改<code>atomic.AddUnit64</code>）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 表示 `WaitGroup` 是不可复制的，只能用指针传递，保证全局唯一</span></span><br><span class="line">   <span class="comment">// noCopy是个空接口，占用0字节，因此内存对齐可以忽略此字段</span></span><br><span class="line">   noCopy noCopy</span><br><span class="line">   </span><br><span class="line">   state1 <span class="type">uint64</span></span><br><span class="line">   state2 <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state 返回指向存储在 wg.state 中的 state(运行计数和等待计数) 和 sema(信号计数) 字段的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> state() (statep *<span class="type">uint64</span>, semap *<span class="type">uint32</span>) &#123;</span><br><span class="line">   <span class="comment">// 判断是否对8对齐，32位也可能满足这种情况，否则要手动padding</span></span><br><span class="line">   <span class="keyword">if</span> unsafe.Alignof(wg.state1) == <span class="number">8</span> || <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 这里对8字节对齐</span></span><br><span class="line">      <span class="comment">// 前8bytes做uint64指针state，后4bytes做sema</span></span><br><span class="line">      <span class="keyword">return</span> &amp;wg.state1, &amp;wg.state2</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 前4bytes做sema，后8bytes做uint64指针state</span></span><br><span class="line">      state := (*[<span class="number">3</span>]<span class="type">uint32</span>)(unsafe.Pointer(&amp;wg.state1))</span><br><span class="line">      <span class="keyword">return</span> (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;state[<span class="number">1</span>])), &amp;state[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了<strong>保证在 32 位系统上也能原子访问 64 位对齐的 64 位字，通过 state() 来消除高层上实现的差异</strong>，具体可以参考<a href="https://link.juejin.cn/?target=https://github.com/golang/go/issues/6404%23issuecomment-66085602">issue-6404</a>。由于在 64 位机器上，8 字节是单个机器字的长度，内存地址对 8 取模可以判断该数据对象的内存地址是否为 64 位对齐，<code>state()</code>对<code>wg.state1</code>的内存地址对 8 进行取模来判断程序是允许在 64 位平台还是 32 位平台上，根据结果来返回信息</p>
<ul>
<li>等于 0 返回： <code>wg.state1</code>(<code>wg.state1[0]</code>) 和<code>wg.state1[2]</code>的内存地址<ul>
<li>此时返回状态、信号</li>
</ul>
</li>
<li>不等于 0（32 位环境）返回：<code>wg.state1[1]</code>和<code>wg.state1[0]</code>的内存地址<ul>
<li>此时返回信号、状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>state 调整的前提：如果不能保证对 8 字节对齐，需要手动移位对齐，这里用了内存对齐的 padding</p>
</blockquote>
<p>在 4 字节对齐的环境中，8 字节可能跨越了两个 cache line，不保证 64 位的原子操作。</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img1.png" alt="img"></p>
<p>在 32 位架构中，WaitGroup 在初始化的时候，分配内存地址的时候是随机的，所以 WaitGroup 结构体 state1 起始的位置<strong>不一定是 64 位对齐</strong>，可能会是：<code>uintptr(unsafe.Pointer(&amp;wg.state1))%8 = 4</code>，如果出现这样的情况，那么就需要用 state1 的第一个元素做 padding + 4，这样操作后两组就能对 8 字节进行对齐了，用 state1 的后两个元素合并成 uint64 来表示 statep，以下是一个小实验：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a <span class="keyword">struct</span> &#123;</span><br><span class="line">   b <span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> w <span class="keyword">struct</span> &#123;</span><br><span class="line">   state1 <span class="type">uint64</span></span><br><span class="line">   state2 <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   b := a&#123;&#125;</span><br><span class="line">   <span class="built_in">println</span>(unsafe.Sizeof(b), <span class="type">uintptr</span>(unsafe.Pointer(&amp;b)), <span class="type">uintptr</span>(unsafe.Pointer(&amp;b))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">   wg := w&#123;&#125;</span><br><span class="line">   <span class="comment">// 64环境下</span></span><br><span class="line">   <span class="comment">// 1 824634031959 false</span></span><br><span class="line">   <span class="comment">// 16 824634031968 true</span></span><br><span class="line">   <span class="comment">// 16 824634031972 false</span></span><br><span class="line">   <span class="comment">// 32环境下 如果是64位win，需要在cmd情况下 set GOARCH=386</span></span><br><span class="line">   <span class="comment">// 1 285454255 false</span></span><br><span class="line">   <span class="comment">// 12 285454260 false</span></span><br><span class="line">   <span class="comment">// 12 285454264 true    经过第一个uint32的padding，后续的两位uint32对8字节对齐</span></span><br><span class="line">   <span class="built_in">println</span>(unsafe.Sizeof(wg), <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1)), <span class="type">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">   state := (*[<span class="number">3</span>]<span class="type">uint32</span>)(unsafe.Pointer(&amp;wg.state1))</span><br><span class="line">   <span class="built_in">println</span>(unsafe.Sizeof(wg), <span class="type">uintptr</span>(unsafe.Pointer(&amp;state[<span class="number">1</span>])), <span class="type">uintptr</span>(unsafe.Pointer(&amp;state[<span class="number">1</span>]))%<span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wait"><a href="#Wait" class="headerlink" title="Wait()"></a>Wait()</h3><p><code>Wait()</code>主要用于<strong>阻塞 g，直到 WaitGroup 的计数为 0</strong>。先获取访问计数值的指针 (state，sema)，在自旋循环体中，通过检查计数来检查目前还没有达成同步条件的并行代码块的数量，并且在每次完成检查后增加一次等待计数。此处没有使用密集循环来构造自旋锁等待，是处于性能考虑：<strong>为了保证其他 goroutine 能够得到充分调度</strong>。如果每一次检查计数时没有达成同步条件，下次循环如果当前 goroutine 不主动让出 CPU，会导致 CPU 空转，降低性能。这里用了<code>runtime_Semacquire(semap)</code>，如果等待计数被成功记录，则直接增加信号量，挂起当前 g，否则再进行一次循环获取最新的同步状态。</p>
<p>Wait() 可以在不同的 g 上执行，且调用 Wait() 的 g 数量也可能不唯一，因此需要等待计数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait blocks until the WaitGroup counter is zero.</span></span><br><span class="line"><span class="comment">// race检测相关代码已略去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123; </span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 原子操作</span></span><br><span class="line">      state := atomic.LoadUint64(statep)</span><br><span class="line">      <span class="comment">// 运行counter（state的高32位）</span></span><br><span class="line">      v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">      <span class="comment">// counter为0时直接返回</span></span><br><span class="line">      <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 增加等待计数</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// 增加信号量并挂起当前g，使当前g让出cpu</span></span><br><span class="line">         <span class="comment">// 信号量为0时唤醒</span></span><br><span class="line">         runtime_Semacquire(semap)</span><br><span class="line">         <span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h3><p><code>Add()</code>不止是简单的将信号量增 delta，还需要考虑很多因素</p>
<ul>
<li>内部运行计数不能为负</li>
<li>Add 必须与 Wait 属于 happens before 关系<ul>
<li>毕竟 Wait 是同步屏障，没有 Add，Wait 就没有了意义</li>
</ul>
</li>
<li>通过信号量通知所有正在等待的 goroutine</li>
</ul>
<p>先假设 statep 的高 32 位&#x3D;1，代表有一个运行计数。当<code>Add(-1)</code>时，statep 的高 32 位 + 负数的补码 32 个 1，会溢出 1 导致 statep 的高 32 位&#x3D;0，即运行计数清零，Wait 操作达成同步条件</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img2.png" alt="img"></p>
<p>具体过程如下：</p>
<ol>
<li>通过 state 获取状态指针 statep 和信号指针 semap，statep 的高 32 位为 counter，低 32 位为 waiter</li>
<li>调用<code>atomic.AddUint64()</code>将传入的 delta 左移四位加上 statep，即 counter+delta</li>
<li>counter 可能为负，所以用 int32 来存值，waiter 不可能为负，所以用 uint32 存值</li>
<li>经过一系列校验，counter 为负则 panic，w 不等于 0 且 delta&gt;0 且 v 值为 delta，说明 add 在 wait 后调用，会 panic，因为 waitGroup 不允许 Wait 方法调用后还调用 add 方法</li>
<li>v &gt; 0 或 w !&#x3D; 0 时直接 return，此时不需要释放 waiter</li>
<li>到了*statep !&#x3D; state，状态只能是 waiter&gt;0 且 counter&#x3D;&#x3D;0，当 waiter&gt;0 时，肯定不能 add，且 counter&#x3D;&#x3D;0 时，wait 不会再自增 waiter，结果一定是一致的，否则触发 panic</li>
<li>将 statep 置为 0，释放所有 waiter</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已略去race检测相关代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取状态指针和信号指针</span></span><br><span class="line">   statep, semap := wg.state()</span><br><span class="line">   <span class="comment">// 在运行计数上记录delta</span></span><br><span class="line">   <span class="comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span></span><br><span class="line">   state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 运行计数</span></span><br><span class="line">   v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">   <span class="comment">// 等待计数（低32位）</span></span><br><span class="line">   w := <span class="type">uint32</span>(state)</span><br><span class="line">   <span class="comment">// 任务计数器不能为负数</span></span><br><span class="line">   <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 添加与等待同时调用（应该是happens before的关系）</span></span><br><span class="line">   <span class="comment">// 已经执行了Wait，不容许再执行Add</span></span><br><span class="line">   <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 运行计数&gt;0或没有writer在等待，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// happens before，add和wait并发调用</span></span><br><span class="line">   <span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 唤醒所有等待的goroutine，并将等待计数清零</span></span><br><span class="line">   <span class="comment">// 此时counter一定为0，waiter一定&gt;0</span></span><br><span class="line">   *statep = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">      <span class="comment">// 执行一次释放一个，唤醒一个waiter</span></span><br><span class="line">      runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Done decrements the WaitGroup counter by one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">   wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WaitGroup-的实现原理总结"><a href="#WaitGroup-的实现原理总结" class="headerlink" title="WaitGroup 的实现原理总结"></a>WaitGroup 的实现原理总结</h3><p>WaitGroup 内部维护了 3 个 uint32（实际上是一个 uint64，一个 uint32），分别是状态和信号，状态包括了运行计数 counter 和等待计数 waiter，信号指信号计数 sema。运行计数代表了调用<code>Add()</code>添加的 delta 值，等待计数代表了调用<code>Wait()</code>陷入等待的 goroutine 的数量，信号量 sema 是 runtime 内部信号量的实现，用于挂起和唤醒 goroutine。在<code>Add()</code>的时候增加运行计数，<code>Wait()</code>的时候增加等待计数，如果运行计数不为 0，则将 goroutine 挂起，等到调用<code>Done()</code>-&gt;Add(-1) 使等待计数为 0 时会唤醒所有挂起的 goroutine。</p>
<p>我觉得比较核心的地方在于<strong>3 个 uint32 中兼容 32 位机器和 64 位机器的实现</strong>。由于状态是 64 位的，需要进行 64 位原子操作更新，但是由于 32 位的环境只对 4 字节对齐，首字段可能不是对 8 字节对齐的，因此要用 state 进行兼容，如果不对 8 字节对齐，则将状态放在后面两位 uint32 中，前面一个 4 字节的作为 padding，存放信号计数 sema。如果对 8 字节对齐，状态直接放在前两位即可，这样就兼容了 32 位和 64 位对 64 位原子操作的支持。</p>
<h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p>sync.Pool 也许应该叫 sync.Cache，简单来说就是<strong>为了避免频繁分配、回收内存给 GC 带来负担</strong>的 cache，pool 与连接池类似。sync.Pool 可以<strong>将暂时不用的对象缓存起来，等到下次需要的时候直接使用</strong>，也不用再次经过内存分配，复用对象的内存，减轻了 GC 的压力，提升系统性能。</p>
<h3 id="如果没有-sync-Pool"><a href="#如果没有-sync-Pool" class="headerlink" title="如果没有 sync.Pool"></a>如果没有 sync.Pool</h3><p>多个 goroutine 都需同时创建一个对象时，如果 goroutine 数过多，会导致对象的创建数目递增，导致 GC 压力过大。形成’并发大-&gt;占用内存大-&gt;GC 缓慢-&gt;处理并发能力降低-&gt;并发更大’的恶性循环。解决此问题的关键思想就在于对象的<strong>复用</strong>，避免重复创建、销毁。</p>
<p>以下是一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool *sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   pool = &amp;sync.Pool&#123;</span><br><span class="line">      New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;creating a new person&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">new</span>(Person)</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   person := pool.Get().(*Person)</span><br><span class="line">   fmt.Println(<span class="string">&quot;Get Pool Object：&quot;</span>, person)</span><br><span class="line">   person.Name = <span class="string">&quot;first&quot;</span></span><br><span class="line">   pool.Put(person)</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;Get Pool Object：&quot;</span>, pool.Get().(*Person))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Get Pool Object：&quot;</span>, pool.Get().(*Person))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">creating a new person</span><br><span class="line">Get Pool Object： &amp;&#123;&#125;     </span><br><span class="line">Get Pool Object： &amp;&#123;first&#125;</span><br><span class="line">creating a new person     </span><br><span class="line">Get Pool Object： &amp;&#123;&#125; </span><br></pre></td></tr></table></figure>

<p>在以上代码中，<code>init()</code>创建了一个 sync.Pool，实现的<code>New()</code>方法为创建一个 person 对象，并打印一句话，<code>main()</code>中调用了三次 Get() 和一次 Put。根据输出结果看来，如果在调用<code>Get()</code>时，pool 中没有对象，那么就会调用<code>New()</code>创建新的对象，否则会从 pool 中的对象获取。我们还可以看到，put 到 pool 中的对象属性依然是之前设定的，并没有被重置。</p>
<p>sync.Pool 广泛运用于各种场景，典型例子是 fmt 包中的 print：</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img3.png" alt="img"></p>
<h3 id="sync-Pool-的底层实现"><a href="#sync-Pool-的底层实现" class="headerlink" title="sync.Pool 的底层实现"></a>sync.Pool 的底层实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// go1.7引入的一个静态检查机制，代表该对象不希望被复制，可以使用go vet工具检测到是否被复制</span></span><br><span class="line">   <span class="comment">// 在使用时需要实现noCopy保证一个对象第一次使用后不会发生复制</span></span><br><span class="line">   noCopy     noCopy</span><br><span class="line">   local      unsafe.Pointer <span class="comment">// 每个P的本地队列，实际类型为[P]poolLocal, 一个切片</span></span><br><span class="line">   localSize  <span class="type">uintptr</span>        <span class="comment">// 大小</span></span><br><span class="line">   victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">   victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line">   <span class="comment">// 自定义创建对象回调函数，当pool中没有可用对象时会调用此函数</span></span><br><span class="line">   <span class="comment">// 当没有可用对象时，如果不设置该函数，get()会返回nil</span></span><br><span class="line">   New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>noCopy 代表这个结构体是禁止拷贝的，在使用 go vet 工具时生效。</p>
<p>local 是一个 poolLocal 数组（其实是切片<code>local := make([]poolLocal, size)</code>）的指针，localSize 代表这个数组的大小，victim 也是一个 poolLocal 数组的指针。</p>
<p>New 函数在创建 pool 时设置，当 pool 中没有缓存对象时，会调用 New 方法生成一个新的对象。</p>
<p>在索引 poolLocal 时，P 的 id 对应[P]poolLocal 下标索引，这样在多个 goroutine 使用同一个 pool 时能减少竞争，提升了性能。在一轮 GC 到来时，victim 和 victimSize 会分别接管 local 和 localSize，victim 机制用于减少 GC 后冷启动导致的性能抖动，使得分配对象更加平滑</p>
<blockquote>
<p>Victim Cache 是计算机架构里的一个概念，是 CPU 硬件处理缓存的一种技术，sync.Pool 引入它的目的在于降低 GC 压力的同时提高命中率。</p>
</blockquote>
<h3 id="poolLocal"><a href="#poolLocal" class="headerlink" title="poolLocal"></a>poolLocal</h3><p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img4.png" alt="img"></p>
<p>这里得提到<strong>伪共享</strong>问题。伪共享问题，就是在多核 CPU 架构下，为了满足数据一致性维护一致性协议 MESI，频繁刷新同一 cache line 导致高速缓存并未起到应有的作用的问题。试想一下，两个独立线程要更新两个独立变量，但<strong>俩独立变量都在同一个 cache line 上</strong>，当前 cache line 是 share 状态。如果 core0 的 thread0 去更新 cache line，会导致 core1 中的 cache line 状态变为 Invalid，随后 thread1 去更新时必须通知 core0 将 cache line 刷回主存，然后它再从主从中 load 该 cache line 进高速缓存之后再进行修改，但是该修改又会使得 core0 的 cache line 失效，重复上述过程，导致高速缓存相当于没有一样，反而还因为频繁更新 cache 影响了性能。</p>
<p>这里 poolLocal 的字段 pad 就是用于防止伪共享问题，cache line 在 x86_64 体系下一般是 64 字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">   poolLocalInternal</span><br><span class="line">   <span class="comment">// 将poolLocal补齐至缓存行的大小，防止false sharing（伪共享）</span></span><br><span class="line">   <span class="comment">// 在多数平台上128 mod (cache line size) = 0可以防止伪共享</span></span><br><span class="line">   <span class="comment">// 伪共享，仅占位用，防止在cache line上分配多个poolLocalInternal</span></span><br><span class="line">   pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poolLocal 数组的大小是程序中 P 的数量，Pool 的最大个数是<code>runtime.GOMAXPROCS(0)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Local per-P Pool appendix.</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// P的私有缓存区，使用时不需要加锁</span></span><br><span class="line">   private any       <span class="comment">// Can be used only by the respective P.</span></span><br><span class="line">    <span class="comment">// 公共缓存区，本地P可用pushHead/popHead。其他的P只能popTail</span></span><br><span class="line">   shared  poolChain <span class="comment">// Local P can pushHead/popHead; any P can popTail.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poolLocalInternal 中 private 代表缓存了一个元素，只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，因此不会有并发问题，使用时不需要加锁。</p>
<p>shared 则可以由任意的 P 访问，但是只有本地的 P 才能 pushHead 或 popHead，其他 P 可以 popTail。</p>
<h3 id="poolChain"><a href="#poolChain" class="headerlink" title="poolChain"></a>poolChain</h3><p>看看 poolChain 的实现，这是一个双端队列的实现</p>
<p>其中 poolDequeue 是 PoolQueue 的一个实现，实现为单生产者多消费者的固定大小的无锁 Ring 式队列，通过 atomic 实现，底层存储用数组，head，tail 标记。</p>
<p>生产者可以从 head 插入，tail 删除，而消费者只能从 tail 删除。headTail 变量通过位运算存储了 head 和 tail 的指针，分别指向队头与队尾。</p>
<p>poolChain 没有使用完整的 poolDequeue，而是封装了一层，这是因为它的大小是固定长度的，而 pool 则是不限制大小的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: /sync/poolqueue.go</span></span><br><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 只有生产者会push，因此不需要加锁同步</span></span><br><span class="line">   head *poolChainElt</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 能被消费者使用，所以操作必须要有原子性</span></span><br><span class="line">   tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;</span><br><span class="line">   poolDequeue</span><br><span class="line">    <span class="comment">// next被producer写，consumer读，所以只会从nil变成non-nil</span></span><br><span class="line">    <span class="comment">// prev被consumer写，producerr读，所以只会从non-nil变成nil</span></span><br><span class="line">   next, prev *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含了一个32位head指针和一个32位tail指针，都与len(vals) - 1取模过</span></span><br><span class="line">    <span class="comment">// tail是队列中最老是数据，head指向下一个要填充的slot</span></span><br><span class="line">    <span class="comment">// slots范围是[tail, head)，由consumers持有</span></span><br><span class="line">    <span class="comment">// 高32位为head，低32位为tail</span></span><br><span class="line">   headTail <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// vals是一个存储interface&#123;&#125;的环形队列，size必须是2的幂</span></span><br><span class="line">    <span class="comment">// 如果slot为空，则vals[i].typ为空</span></span><br><span class="line">    <span class="comment">// 一个slot在此宣告无效，那么tail就不指向它了，vals[i].typ为nil</span></span><br><span class="line">    <span class="comment">// 由consumers设置为nil，由producer读</span></span><br><span class="line">   vals []eface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">   typ, val unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此图可以看到 pool 的整体结构</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img5.png" alt="img"></p>
<h3 id="获取一个对象-Get"><a href="#获取一个对象-Get" class="headerlink" title="获取一个对象-Get()"></a>获取一个对象-Get()</h3><p><code>Get()</code>的过程清晰明了：</p>
<ol>
<li>首先通过调用<code>p.pin()</code>将当前 goroutine 与 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal 以及 pid。</li>
<li>获取 local 的 private 赋给 x，并置 local 的 private 为 nil</li>
<li>判断 x 是否为空，若为空，则尝试从 local 的 shared 头部获取一个对象，赋值给 x。如果 x 仍然为空，会调用<code>getSlow()</code>从其他 P 的 shared 尾部偷取一个对象</li>
<li>调用<code>runtime_procUnpin()</code>解除非抢占。</li>
<li>如果到此时还没有获取到对象，调用设置的<code>New()</code>创建一个新对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() any &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 将当前goroutine绑定到当前p上</span></span><br><span class="line">   l, pid := p.pin()</span><br><span class="line">   <span class="comment">// 优先从local的private中获取</span></span><br><span class="line">   x := l.private</span><br><span class="line">   l.private = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 如果local的private没有，尝试获取local shared的head</span></span><br><span class="line">      x, _ = l.shared.popHead()</span><br><span class="line">      <span class="comment">// 如果还没有，则进入slow path</span></span><br><span class="line">      <span class="comment">// 调用</span></span><br><span class="line">      <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">         x = p.getSlow(pid)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解除抢占</span></span><br><span class="line">   runtime_procUnpin()</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 如果没有获取到，尝试使用New()创建一个新对象</span></span><br><span class="line">   <span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">      x = p.New()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pin"><a href="#pin" class="headerlink" title="pin()"></a>pin()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">   pid := runtime_procPin()</span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume</span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line">   <span class="comment">// 传入的i是数组的index</span></span><br><span class="line">   lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line">   <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用是<strong>将当前 goroutine 与 P 绑定在一起，禁止抢占</strong>，且返回对应 poolLocal 和 P 的 id。</p>
<p>如果 goroutine 被抢占，那么 g 的状态会从 running 变为 runnable，会被放回 P 的 localq 或 globalq，等待下一次调度。但当 goroutine 下次再次执行时，就不一定和现在的 P 结合了，因为之后会用到 pid，如果被抢占，可能接下来使用的 pid 与绑定的 pid 不是同一个。</p>
<p>绑定的逻辑主要在<code>procPin()</code>中。它将当前 gorotuine 绑定的 m 上的 locks 字段 +1，即完成了绑定。调度器执行调度时，又是会抢占当前执行 goroutine 所绑定的 P，防止一个 goroutine 占用 CPU 过长时间。而判断一个 goroutine 能被被抢占的条件就是看 m.locks 是否为 0，若为 0，则可以被抢占。而在<code>procPin()</code>中，m.locks+1，表示不能被抢占。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procPin</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   _g_ := getg()</span><br><span class="line">   mp := _g_.m</span><br><span class="line"></span><br><span class="line">   mp.locks++</span><br><span class="line">   <span class="keyword">return</span> <span class="type">int</span>(mp.p.ptr().id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>p.pin()</code>中，获取到 p.localSize 和 p.local 后，如果当前 pid 小于 p.localSize，则直接获取 poolLocal 数组中 pid 索引处的位置，否则说明 Pool 还没有创建 poolLocal，调用<code>p.pinSlow()</code>完成创建。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="comment">// 解除绑定</span></span><br><span class="line">   <span class="comment">// 避免上大锁造成阻塞，浪费资源</span></span><br><span class="line">   runtime_procUnpin()</span><br><span class="line">   <span class="comment">// 加全局锁</span></span><br><span class="line">   allPoolsMu.Lock()</span><br><span class="line">   <span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">   <span class="comment">// 重新绑定</span></span><br><span class="line">   pid := runtime_procPin()</span><br><span class="line">   <span class="comment">// 已经加了全局锁，此时不需要再用原子操作</span></span><br><span class="line">   s := p.localSize</span><br><span class="line">   l := p.local</span><br><span class="line">   <span class="comment">// 对pid重新检查，因为pinSlow途中可能已经被其他线程调用了</span></span><br><span class="line">   <span class="comment">// 如果已经创建过了，那么直接返回即可</span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 初始化时会将pool放到allPools中</span></span><br><span class="line">   <span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">      allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 当前P数量</span></span><br><span class="line">   <span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">   size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">   local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">   <span class="comment">// 回收旧的local</span></span><br><span class="line">   atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">   runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release</span></span><br><span class="line">   <span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pinSlow()</code>在加锁的情况下进行重试，加全局锁创建一个 poolLocal。整体过程如下：</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img6.png" alt="img"></p>
<h4 id="popHead"><a href="#popHead" class="headerlink" title="popHead()"></a>popHead()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">   d := c.head</span><br><span class="line">   <span class="keyword">for</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> val, ok := d.popHead(); ok &#123;</span><br><span class="line">         <span class="comment">// 如果成功获得值，则返回</span></span><br><span class="line">         <span class="keyword">return</span> val, ok</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 继续尝试获取缓存的对象</span></span><br><span class="line">      d = loadPoolChainElt(&amp;d.prev)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>popHead()</code>只会被生产者调用。函数执行时先拿到头节点，如果不为空，则调用头节点的<code>popHead()</code>。这俩<code>popHead()</code>的实现不一致。poolDequeue 的<code>popHead()</code>移除并返回 queue 的头节点，如果 queue 为空，会返回 false。此处 queue 中存储的对象就是 Pool 里缓存的对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popHead() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> slot *eface</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">      head, tail := d.unpack(ptrs)</span><br><span class="line">      <span class="comment">// queue为空</span></span><br><span class="line">      <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 验证尾节点，并自减头节点指针，这个操作在读出slot的value之前执行。</span></span><br><span class="line">      <span class="comment">// 此处是为了锁住head指针的位置，下一步CAS保证去除的必然是头节点</span></span><br><span class="line">      head--</span><br><span class="line">      ptrs2 := d.pack(head, tail)</span><br><span class="line">      <span class="comment">// 典型CAS</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">         <span class="comment">// 成功取出value</span></span><br><span class="line">         <span class="comment">// 实际就是取head低n位的值</span></span><br><span class="line">         slot = &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">   <span class="comment">// 获取到nil的话就是nil了</span></span><br><span class="line">   <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">      val = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重置slot。和popTail不同，这里不会与pushHead产生竞态条件。</span></span><br><span class="line">   *slot = eface&#123;&#125;</span><br><span class="line">   <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>poolChain.popHead()</code>，如果获取成功则直接返回，否则继续尝试。</p>
<h4 id="getSlow"><a href="#getSlow" class="headerlink" title="getSlow()"></a>getSlow()</h4><p><code>getSlow()</code>在 shared 没有获取到缓存对象的情况下，会尝试从其他 P 的 poolLocal 偷取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) any &#123;</span><br><span class="line">   <span class="comment">// See the comment in pin regarding ordering of the loads.</span></span><br><span class="line">   size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">   locals := p.local                            <span class="comment">// load-consume</span></span><br><span class="line">   <span class="comment">// 尝试从其他P偷取对象</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">      <span class="comment">// 从索引pid+1处开始投</span></span><br><span class="line">      l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))</span><br><span class="line">      <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> x</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 在尝试从其他P偷取对象失败后，会尝试从victim cache中取对象</span></span><br><span class="line">   <span class="comment">// 这样可以使得victim中的对象更容易被回收</span></span><br><span class="line">   size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   locals = p.victim</span><br><span class="line">   l := indexLocal(locals, pid)</span><br><span class="line">   <span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">      l.private = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;</span><br><span class="line">      l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))</span><br><span class="line">      <span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> x</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 清空victim，防止后来人再来这里找</span></span><br><span class="line">   atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>Get()</code>，如果实在偷不到，后面会通过<code>New()</code>创建一个新的对象。</p>
<h4 id="popTail"><a href="#popTail" class="headerlink" title="popTail()"></a>popTail()</h4><p><code>popTail()</code>将 queue 尾部元素弹出，类似<code>popHead()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">   d := loadPoolChainElt(&amp;c.tail)</span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> pop前先加载next，此处与一般的双向链表是相反的</span></span><br><span class="line">      d2 := loadPoolChainElt(&amp;d.next)</span><br><span class="line">      <span class="keyword">if</span> val, ok := d.popTail(); ok &#123;</span><br><span class="line">         <span class="keyword">return</span> val, ok</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 队列为空，只有一个尾结点</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 双向链表尾节点的queue已经为空，看下一个节点</span></span><br><span class="line">      <span class="comment">// 因为它为空，需要pop掉</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;</span><br><span class="line">         storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 防止下次popTail的时候会看到一个空的dequeue</span></span><br><span class="line">      d = d2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层用的还是 poolDequeue 的<code>popTail()</code>，与寻常实现大体类似，也是 CAS。因为要移除尾部元素，所以 tail 自增 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (any, <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> slot *eface</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">      head, tail := d.unpack(ptrs)</span><br><span class="line">      <span class="keyword">if</span> tail == head &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      ptrs2 := d.pack(head, tail+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;</span><br><span class="line">         slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   val := *(*any)(unsafe.Pointer(slot))</span><br><span class="line">   <span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;</span><br><span class="line">      val = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   slot.val = <span class="literal">nil</span></span><br><span class="line">   atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img7.png" alt="img"></p>
<h3 id="存放一个对象-Put"><a href="#存放一个对象-Put" class="headerlink" title="存放一个对象-Put()"></a>存放一个对象-Put()</h3><p><code>Put()</code>将对象添加到 Pool 中，主要过程如下：</p>
<ol>
<li>绑定当前 goroutine 与 P，然后尝试将 x 赋值给 private</li>
<li>如果失败，则将其放入 local shared 的头部</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x any) &#123;</span><br><span class="line">   <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   l, _ := p.pin()</span><br><span class="line">   <span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">      l.private = x</span><br><span class="line">      x = <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">      l.shared.pushHead(x)</span><br><span class="line">   &#125;</span><br><span class="line">   runtime_procUnpin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pushHead"><a href="#pushHead" class="headerlink" title="pushHead()"></a>pushHead()</h4><p>如果头节点为空，则初始化一下，默认大小为 8。然后调用<code>poolDequeue.pushHead()</code>将其 push 到队列中，如果失败，则说明队列已满，会创建一个两倍大小的 dequeue，然后再次调用<code>poolDequeue.pushHead()</code>。由于前面 g 与 p 已经绑定了，所以不会有竞态条件，这里只需要一次重试就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dequeueBits = <span class="number">32</span></span><br><span class="line"><span class="keyword">const</span> dequeueLimit = (<span class="number">1</span> &lt;&lt; dequeueBits) / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val any) &#123;</span><br><span class="line">   d := c.head</span><br><span class="line">   <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化头节点，初始大小为8</span></span><br><span class="line">      <span class="keyword">const</span> initSize = <span class="number">8</span></span><br><span class="line">      d = <span class="built_in">new</span>(poolChainElt)</span><br><span class="line">      d.vals = <span class="built_in">make</span>([]eface, initSize)</span><br><span class="line">      c.head = d</span><br><span class="line">      storePoolChainElt(&amp;c.tail, d)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将其push到队列中，如果成功则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> d.pushHead(val) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 当前dequeue满了，分配一个新的两倍大小的dequeue</span></span><br><span class="line">   newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span></span><br><span class="line">   <span class="keyword">if</span> newSize &gt;= dequeueLimit &#123;</span><br><span class="line">      <span class="comment">// dequeue最大限制为2^30</span></span><br><span class="line">      newSize = dequeueLimit</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   d2 := &amp;poolChainElt&#123;prev: d&#125;</span><br><span class="line">   d2.vals = <span class="built_in">make</span>([]eface, newSize)</span><br><span class="line">   c.head = d2</span><br><span class="line">   storePoolChainElt(&amp;d.next, d2)</span><br><span class="line">   d2.pushHead(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层用的还是 poolDequeue 的<code>pushHead()</code>，他将 val 添加到队列头部，如果队列满了会返回 false，走刚才创建新一个两倍大小队列的路，这个函数只能被一个生产者调用，因此不会有竞态条件。首先通过位运算判断队列是否已满，将 tail 加上当前 dequeue 内节点的数量，即 d.vals 的长度，再取低 31 位，看看它与 head 是否相等，相等的话就说明队列满了，如果满了直接返回 false。否则通过 head 找到即将填充的 slot 位置，去 head 指针的低 31 位，判断是否有另一个 goroutine 在 popTail 这个 slot，如果有则返回 false。这里是判断 typ 是否为空，因为 popTail 是先设置 val，再将 typ 设置为 nil 的。最后将 val 赋值给 slot，自增 head。</p>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img8.png" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val any) <span class="type">bool</span> &#123;</span><br><span class="line">   ptrs := atomic.LoadUint64(&amp;d.headTail)</span><br><span class="line">   <span class="comment">// 解包，高32位为head，低32位为tail</span></span><br><span class="line">   head, tail := d.unpack(ptrs)</span><br><span class="line">   <span class="comment">// 判断队列是否已满</span></span><br><span class="line">   <span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;</span><br><span class="line">      <span class="comment">// 队列满了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 找到即将填充的slot位置</span></span><br><span class="line">   slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]</span><br><span class="line">   <span class="comment">// 检查slot是否与popTail有冲突</span></span><br><span class="line">   typ := atomic.LoadPointer(&amp;slot.typ)</span><br><span class="line">   <span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 另一个g在popTail这个slot，说明这个队列仍然是满的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line">      val = dequeueNil(<span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将val赋值给slot</span></span><br><span class="line">   *(*any)(unsafe.Pointer(slot)) = val</span><br><span class="line">   <span class="comment">// 自增head</span></span><br><span class="line">   atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在*<code>(*any)(unsafe.Pointer(slot)) = val</code>中，由于 slot 是 eface 类型，先将 slot 转换为 interface{}类型，这样 val 就能以 interface{}类型赋值给 slot，使得 slot.typ 和 slot.val 指向其内存块，slot 的 typ, val 均不为空。</p>
<h4 id="pack"><a href="#pack" class="headerlink" title="pack()"></a>pack()</h4><p>再来看看<code>pack()</code>和<code>unpack()</code>，它们的作用是打包和解包 head 和 tail 俩指针。实际上很简单，<code>pack()</code>就是将 head 左移 32 位，或上 tail 与低 31 位全 1，返回整合成的 uint64。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |</span><br><span class="line">      <span class="type">uint64</span>(tail&amp;mask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unpack()</code>则将整合的 uint64 右移 32 位与上低 31 位全 1，得到 head，而 tail 则是低 32 位与上低 31 位全 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span></span><br><span class="line">   head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)</span><br><span class="line">   tail = <span class="type">uint32</span>(ptrs &amp; mask)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>Pool 实际上也不能无限扩展，否则会因为对象占用内存过多导致 OOM。在 pool.go 的<code>init()</code>中，注册了 GC 发生时如何清理 Pool 的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime_registerPoolCleanup(poolCleanup)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/mgc.go</span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup</span></span><br><span class="line"><span class="comment">// 利用编译器标志将sync包的清理注册到runtime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line">   poolcleanup = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上调用的是<code>pool.poolCleanup()</code>，主要是将 local 与 victim 进行交换，不至于让 GC 将所有的 Pool 都清空，有 victim 兜底，需要两个 GC 周期才会被释放。如果 sync.Pool 的获取、释放速度稳定，就不会有新的 Pool 对象进行分配，如果获取的速度下降，那么对象可能会在两个 GC 周期内被释放，而不是以前的一个 GC 周期。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;</span><br><span class="line">      p.victim = <span class="literal">nil</span></span><br><span class="line">      p.victimSize = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Move primary cache to victim cache.</span></span><br><span class="line">   <span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;</span><br><span class="line">      p.victim = p.local</span><br><span class="line">      p.victimSize = p.localSize</span><br><span class="line">      p.local = <span class="literal">nil</span></span><br><span class="line">      p.localSize = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The pools with non-empty primary caches now have non-empty</span></span><br><span class="line">   <span class="comment">// victim caches and no pools have primary caches.</span></span><br><span class="line">   oldPools, allPools = allPools, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面模拟一下调用<code>poolCleanup()</code>前后，oldPools，allPools 与 p.victim 的变化：</p>
<ol>
<li>初始时 oldPools 与 allPools 都为 nil</li>
<li>第一次调用<code>Get()</code>，因为 p.local 为 nil，会通过<code>pinSlow()</code>创建 p.local，将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil</li>
<li>对象使用完毕，调用<code>Put()</code>放回对象</li>
<li>第一次 GC STW，allPools 中所有 p.local 赋值给 victim，并置为 nil。allPools 赋值给 oldPools，置为 nil。此时 oldPools 长度为 1，allPools 为 nil</li>
<li>第二次调用<code>Get()</code>，由于 p.local 为 nil，会尝试从 p.victim 中获取对象。</li>
<li>对象使用完毕，调用<code>Put()</code>放回对象。由于 p.local 为 nil，会重新创建 p.local，并放回对象，此时 allPools 长度为 1，oldPools 长度也为 1</li>
<li>第二次 GC STW，oldPools 中所有 p.victim 置为 nil，前一次 cache 在本次 GC 时被回收，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。最后 allPools 为 nil，oldPools 长度为 1。</li>
</ol>
<p>从以上可以看出，p.victim 的定位是<strong>次级缓存</strong>，在 GC 时将对象放到其中，下次 GC 来临前，如果有<code>Get()</code>调用则从其中获取，直到再一次 GC 到来时回收。从 victim 中取出的对象并不放回 victim 中，一定程度上也减小了下一次 GC 的开销，使得原先一次 GC 的开销被拉长到两次，有一定程度的开销减小。</p>
<h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>Mutex 是公平互斥锁</p>
<p>每个 g 去获取锁的时候都会<strong>尝试自旋几次</strong>，如果没有获取到则进入等待队列尾部（<strong>先入先出</strong>FIFO）。当持有锁的 g 释放锁时，位于等待队列头部的 g 会被唤醒，但是需要与后来 g 竞争，当然竞争不过，因为后来 g 运行在 cpu 上处于自旋状态，且后来 g 会有很多，而刚唤醒的 g 只有一个，只能被迫重新插回头部。当等待的 g 本次加锁等待时间超过 1ms 都没有获得锁时，它会将当前 Mutex 从正常模式切换为<strong>饥饿模式</strong>，Mutex 所有权会直接从释放锁的 g 上直接传给队头的 g，后来者不自旋也不会尝试获取锁，会直接进入等待队列尾部。</p>
<p>当发生以下两种情况时 Mutex 会从饥饿模式切换为正常模式</p>
<ul>
<li>获取到锁的 g 刚来，等待时间小于 1ms</li>
<li>该 g 是等待队列中最后一个 g</li>
</ul>
<blockquote>
<p>饥饿模式下不再尝试自旋，所有 g 都要排队，严格先来后到，可以防止尾端延迟</p>
</blockquote>
<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img9.png" alt="img"></p>
<p>互斥锁 state 的最低三位分别标识<strong>mutexLocked</strong>、<strong>mutexWoken</strong>和<strong>mutexStarving</strong>，剩余位置用于标识当前有多少个 g 在等待互斥锁释放</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// The zero value for a Mutex is an unlocked mutex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Mutex must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">// 状态</span></span><br><span class="line">   state <span class="type">int32</span></span><br><span class="line">   <span class="comment">// 信号量</span></span><br><span class="line">   sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看 lock 与 unlock。lock 会锁住 Mutex，如果这个锁在被使用，那么调用的 g 会被阻塞直到这个互斥锁被释放。当锁 state 为 0 时，会将 mutexLocked 位置置为 1，当 state 不是 0 时，会调用<code>sync.Mutex.lockSlow()</code>尝试通过自旋等方式来等待锁的释放。</p>
<p>自旋是一种多线程同步机制，当前进程在进入自旋的过程中会一直保持对 CPU 的占用，持续检查某个条件是否为真，在多核 CPU 上，自旋可以避免 goroutine 的切换，某些情况下能对显著提升性能。g 在进入自旋的需要满足的条件如下</p>
<ol>
<li>互斥锁只有在普通模式才能进入自旋</li>
<li><code>runtime.sync_runtime_canSpin()</code>返回 true<ol>
<li>在多 CPU 机器上</li>
<li>当前 g 为了获取该锁进入自旋次数少于 4 次</li>
<li>GOMAXPROCS &gt; 1，至少一个其他 P 在 running，且当前 p 本地 runq 为空</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">   <span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">   <span class="comment">// 争锁，实现fast path</span></span><br><span class="line">   <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">      ... race检测相关</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 便于编译器对fast path进行内联优化</span></span><br><span class="line">   <span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">   m.lockSlow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果CAS没有获得锁则进入slow path</span></span><br><span class="line"><span class="comment">// 主体是一个很大的for循环，主要由以下过程组成</span></span><br><span class="line"><span class="comment">// 1. 判断当前g能否进入自旋</span></span><br><span class="line"><span class="comment">// 2. 通过自旋等待互斥锁释放</span></span><br><span class="line"><span class="comment">// 3. 计算互斥锁的最新状态</span></span><br><span class="line"><span class="comment">// 4. 更新互斥锁的状态并获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">   <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">   starving := <span class="literal">false</span></span><br><span class="line">   awoke := <span class="literal">false</span></span><br><span class="line">   iter := <span class="number">0</span></span><br><span class="line">   old := m.state</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// 饥饿模式下无法自旋</span></span><br><span class="line">      <span class="comment">// 告知持有锁的g，在唤醒锁的时候不用再唤醒其他g了</span></span><br><span class="line">      <span class="comment">// old&amp;(mutexLocked|mutexStarving) == mutexLocked 必须是上锁、不能处于饥饿状态</span></span><br><span class="line">      <span class="comment">// runtime_canSpin(iter)看看自旋次数iter是否超过4，是否在多CPU机器上运行，是否有运行中的P且runq为空</span></span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">         <span class="comment">// !awoke是否是唤醒状态</span></span><br><span class="line">         <span class="comment">// old&amp;mutexWoken == 0没有其他正在唤醒的节点</span></span><br><span class="line">         <span class="comment">// old&gt;&gt;mutexWaiterShift != 0 表示当前有正在等待的goroutine</span></span><br><span class="line">         <span class="comment">// atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) CAS将mutexWoken状态位设置为1</span></span><br><span class="line">         <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">            <span class="comment">// 设置唤醒状态位真</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 执行30次PAUSE指令占用CPU并消耗CPU时间</span></span><br><span class="line">         runtime_doSpin()</span><br><span class="line">         <span class="comment">// 自旋次数加一</span></span><br><span class="line">         iter++</span><br><span class="line">         <span class="comment">// 获取当前锁状态</span></span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ---------------------------------------------------</span></span><br><span class="line">      <span class="comment">// 处理完自旋逻辑后，会根据上下文计算当前互斥锁的最新状态</span></span><br><span class="line">      <span class="comment">// 当前情况有两种1.自旋超过了次数 2.目前锁没有被持有</span></span><br><span class="line">      <span class="built_in">new</span> := old</span><br><span class="line">      <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// 如果当前不是饥饿模式，那么将mutexLocked状态位设置1，表示加锁</span></span><br><span class="line">         <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="comment">// 如果old被锁定或者处于饥饿模式，则waiter加一，表示等待一个等待计数</span></span><br><span class="line">         <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果是饥饿状态，并且已经上锁了，那么mutexStarving状态位设置为1，设置为饥饿状态</span></span><br><span class="line">      <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// awoke为true则表明当前线程在上面自旋的时候，修改mutexWoken状态成功</span></span><br><span class="line">      <span class="keyword">if</span> awoke &#123;</span><br><span class="line">         <span class="comment">// g被唤醒了，无论要抢锁还是排队，操作完后都不是被唤醒的g了</span></span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 清除唤醒标志位，后续流程可能g被挂起，需要其他释放锁的g来唤醒</span></span><br><span class="line">         <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ---------------------------------------------------</span></span><br><span class="line">      <span class="comment">// 使用CAS函数更新状态</span></span><br><span class="line">      <span class="comment">// 在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</span></span><br><span class="line">      <span class="comment">// 在饥饿模式下，当前 Goroutine 会获得互斥锁</span></span><br><span class="line">      <span class="comment">// 如果等待队列中只有当前 Goroutine，互斥锁还会从饥饿模式中退出；</span></span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">         <span class="comment">// 1.如果原来状态没有上锁，也没有饥饿，那么直接返回，表示获取到锁</span></span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 2.到这里是没有获取到锁，判断一下等待时长是否不为0</span></span><br><span class="line">         <span class="comment">// 如果之前已经等过，则放到队列头部</span></span><br><span class="line">         queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">         <span class="comment">// 3.如果等待时间为0，那么初始化等待时间</span></span><br><span class="line">         <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">            waitStartTime = runtime_nanotime()</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 4.阻塞等待</span></span><br><span class="line">         <span class="comment">// 如果没有通过CAS获取到锁，则会调用此函数通过信号量来保证资源不会被两个g同时获取</span></span><br><span class="line">         <span class="comment">// 会在方法中不断尝试获取锁并陷入休眠等待信号量释放, 一旦当前g获取到信号量，会立即返回继续执行下文逻辑</span></span><br><span class="line">         runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">         <span class="comment">// 5.唤醒之后检查锁是否应该处于饥饿状态</span></span><br><span class="line">         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="comment">// 6.判断是否已经处于饥饿状态</span></span><br><span class="line">         <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">               throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.加锁并且将waiter数减1</span></span><br><span class="line">            delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">            <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">               <span class="comment">// 8.如果当前goroutine不是饥饿状态，就从饥饿模式切换会正常模式</span></span><br><span class="line">               delta -= mutexStarving</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 9.设置状态</span></span><br><span class="line">            atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         awoke = <span class="literal">true</span></span><br><span class="line">         iter = <span class="number">0</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    active_spin     = <span class="number">4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Active spinning for sync.Mutex.</span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="comment">// sync.Mutex is cooperative, so we are conservative with spinning.</span></span><br><span class="line">   <span class="comment">// Spin only few times and only if running on a multicore machine and</span></span><br><span class="line">   <span class="comment">// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</span></span><br><span class="line">   <span class="comment">// As opposed to runtime mutex we don&#x27;t do passive spinning here,</span></span><br><span class="line">   <span class="comment">// because there can be work on global runq or on other Ps.</span></span><br><span class="line">   <span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlock 的过程比 lock 的过程简单，fast path 通过去除 mutexLocked 标志位来快速解锁，如果失败，则进入 slow path。slow path 先判断是否已经被解锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">   ...race检测相关</span><br><span class="line">   <span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">   <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 等待队列有g在排队</span></span><br><span class="line">      m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">   <span class="comment">// 先判断是否已经被解锁</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果是正常模式</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">      old := <span class="built_in">new</span></span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="comment">// 如果等待队列为空，或者一个g已经被唤醒或抢到了锁，则不需要唤醒任何g</span></span><br><span class="line">         <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 获取唤醒某个g的机会</span></span><br><span class="line">         <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">         <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 饥饿模式：将互斥锁的所有权直接移交给等待队列头的g，并让出时间片，以便于它可以立即开始运行</span></span><br><span class="line">      <span class="comment">// mutexLocked没有设置1，在等待队列头的g被唤醒后才设置</span></span><br><span class="line">      <span class="comment">// 如果设置了饥饿模式，mutex仍然是被认定为锁定的, 这样才能让新的g不会获取它</span></span><br><span class="line">      runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutex-的实现原理总结"><a href="#Mutex-的实现原理总结" class="headerlink" title="Mutex 的实现原理总结"></a>Mutex 的实现原理总结</h3><p>Mutex 底层是 CAS 实现的，内部维护了一个 int32 的状态 state，用于标识锁状态，以及一个 uint32 的信号量 sema 用于挂起和阻塞 goroutine。Mutex 分为正常模式和饥饿模式，不同模式下<code>Lock()</code>和<code>UnLock()</code>的对加锁、解锁处理方式不同。Mutex 中的 state 第 4 位及其高位用于存放等待计数，低三位的第一位表示锁状态，第二位表示从正常模式被唤醒，第三位表示进入饥饿模式。</p>
<p>Lock() 先通过 CAS 置 state 为 1，如果失败，则进入 slow path 处理：</p>
<ol>
<li>先判断是否可以自旋，饥饿模式下无法自旋<ol>
<li>如果是正常模式，且可以自旋（运行在多 CPU 机器上、当前 g 为了争取该锁进入自旋的次数少于 4、当前机器上至少有个正在运行的 P 且 runq 为空），尝试进行自旋准备：通知运行的 goroutine 不要唤醒其他挂起的 gorotuine，解锁时直接让当前 g 获取锁即可。然后调用<code>runtime_doSpin()</code>进入自旋，执行 30 次 PAUSE 指令占用 CPU，递增自旋次数，重新计算状态</li>
</ol>
</li>
<li>计算锁状态</li>
<li>使用 CAS 更新状态<ol>
<li>成功获取锁：返回</li>
<li>判断等待时间是否为 0，如果是 0 则放在队尾，如果非 0 则放在头部，<strong>进入阻塞</strong></li>
<li>唤醒<ol>
<li>锁是否要进入饥饿状态：等待时间超过 1ms</li>
<li>重新获取锁状态</li>
<li>判断是否处于饥饿状态<ol>
<li>是则可以直接获取锁：自减等待计数，设置状态获取锁，如果 starving 不为饥饿，或等待时间没有超过 1ms，或者只有一个 g 在等待队列中，满足任一条件则切换为正常状态</li>
<li>否：再次循环抢占</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><code>UnLock()</code>先 CAS 置锁状态最低位为 0，如果返回结果不为 0，进入 slow path：</p>
<p>也是分别对正常模式和饥饿模式两种进行分别处理，饥饿模式下将锁的所有权直接移交给等待队列头的 g，并让出时间片，以便于它可以立即开始运行。</p>
<p>正常模式下，通过 CAS 更新状态值，唤醒等待队列中的 waiter。当然，如果没有 waiter，或低三位标志位中有一个不为 0 说明有其他 g 在处理了，直接返回。</p>
<h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p>读写互斥锁不限制并行读，但是读写、写读、写写操作无法并行执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">   w           Mutex  <span class="comment">// 被正在写的g持有</span></span><br><span class="line">   writerSem   <span class="type">uint32</span> <span class="comment">// 写等待读信号量</span></span><br><span class="line">   readerSem   <span class="type">uint32</span> <span class="comment">// 读等待写信号量</span></span><br><span class="line">   readerCount <span class="type">int32</span>  <span class="comment">// 正在读的数量</span></span><br><span class="line">   readerWait  <span class="type">int32</span>  <span class="comment">// 写操作被阻塞时，等待读的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁使用<code>sync.RWMutex.Lock</code>与<code>UnLock</code>，读锁使用<code>RLock</code>和<code>RUnlock</code></p>
<h3 id="Lock-与-UnLock"><a href="#Lock-与-UnLock" class="headerlink" title="Lock 与 UnLock"></a>Lock 与 UnLock</h3><p>Lock 中，先获取内置的互斥锁，获取成功后，其余竞争者 g 会陷入自旋或阻塞。<code>atomic.AddInt32</code>用于阻塞后续的读操作，如果仍有活跃的读操作 g，那么当前写操作 g 会调用 runtime.SemacquireMutex 进入休眠状态等待全部读锁持有者结束后释放 writerSem 信号量，将当前 g 唤醒</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock locks rw for writing.</span></span><br><span class="line"><span class="comment">// If the lock is already locked for reading or writing,</span></span><br><span class="line"><span class="comment">// Lock blocks until the lock is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// ...省略race检测</span></span><br><span class="line">   <span class="comment">// 首先解决与其他写操作的竞争</span></span><br><span class="line">   rw.w.Lock()</span><br><span class="line">   <span class="comment">// 通知读操作者，这是一个写操作</span></span><br><span class="line">   r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">   <span class="comment">// 等待活跃的读操作执行完成</span></span><br><span class="line">   <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)</span></span><br><span class="line">      <span class="comment">// SemacquireMutex 类似于 Semacquire，但用于分析争用的互斥体。如果 lifo 为真，则在等待队列的头部排队等待服务员。 skipframes 是跟踪期间要忽略的帧数，从 runtime_SemacquireMutex 的调用者开始计算。</span></span><br><span class="line">      runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...省略race检测代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的释放过程与加锁过程相反</p>
<ol>
<li>atomic.AddInt32 将 readerCount 变为正数，释放读锁</li>
<li>通过 for 循环唤醒所有阻塞的读操作 g</li>
<li>释放写锁</li>
</ol>
<blockquote>
<p>获取写锁时先阻塞写锁获取，后阻塞读锁获取，释放写锁时，先释放读锁唤醒读操作，后释放写锁。这种策略能够保证读操作不会被连续的写操作饿死</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks rw for writing. It is a run-time error if rw is</span></span><br><span class="line"><span class="comment">// not locked for writing on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As with Mutexes, a locked RWMutex is not associated with a particular</span></span><br><span class="line"><span class="comment">// goroutine. One goroutine may RLock (Lock) a RWMutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to RUnlock (Unlock) it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">   <span class="comment">// ...省略race检测相关</span></span><br><span class="line">   <span class="comment">// 通知所有读者，没有活跃的写操作了</span></span><br><span class="line">   r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">   <span class="comment">// 解锁不存在的读锁会throw</span></span><br><span class="line">   <span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">      race.Enable()</span><br><span class="line">      throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 唤醒所有阻塞的读操作</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">      runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 解锁允许其他写操作者抢占</span></span><br><span class="line">   rw.w.Unlock()</span><br><span class="line">   <span class="comment">// ...省略race检测相关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RLock-与-RUnlock"><a href="#RLock-与-RUnlock" class="headerlink" title="RLock 与 RUnlock"></a>RLock 与 RUnlock</h3><p>读锁的加锁方法不能用于递归读锁定，为不可重入锁，同时，Lock 调用会阻止新的读者获取锁。其中只是将 readerCount+1，如果返回了负数，说明其他 g 获得了写锁，当前 g 就会调用<code>runtime_SemacquireMutex()</code>陷入休眠等待写锁释放。如果返回了正数，则代表 g 没有获取写锁，当前方法返回成功</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RLock locks rw for reading.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">   <span class="comment">// ...省略检测race相关</span></span><br><span class="line">   <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// A writer is pending, wamkit for it.</span></span><br><span class="line">      runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...省略检测race相关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放读锁的方法也很简单，atomic.AddInt32 减少 readerCount 正在读资源的数量，如果返回大于等于 0，则说明解锁成功，如果小于 0，说明有一个正在执行的写操作，会调用 rUnlockSlow 进入 slow path 处理。rUnlockSlow 会减少写操作等待的读操作数 readerWait 并在所有读操作释放后触发写操作的信号量 writeSem，当该信号量触发时，调度器会唤醒尝试获取写锁的 g</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RUnlock undoes a single RLock call;</span></span><br><span class="line"><span class="comment">// it does not affect other simultaneous readers.</span></span><br><span class="line"><span class="comment">// It is a run-time error if rw is not locked for reading</span></span><br><span class="line"><span class="comment">// on entry to RUnlock.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">   <span class="comment">// ...省略检测race相关</span></span><br><span class="line">   <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Outlined slow-path to allow the fast-path to be inlined</span></span><br><span class="line">      rw.rUnlockSlow(r)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...省略检测race相关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">   <span class="comment">// 解锁不存在的读锁会throw</span></span><br><span class="line">   <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">      race.Enable()</span><br><span class="line">      throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// A writer is pending.</span></span><br><span class="line">   <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">      runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与-Mutex"><a href="#与-Mutex" class="headerlink" title="与 Mutex"></a>与 Mutex</h3><p>对于读操作而言主要是使用信号量限制，写操作则是使用互斥锁与信号量限制</p>
<ul>
<li>获取写锁时<ul>
<li>每次解锁读锁都会将 readerCount-1，归零时说明没有读锁获取</li>
<li>将 readerCount 减少 rwmutexMaxReaders 阻塞后续的读操作（将 readerCount 变为负数）</li>
</ul>
</li>
<li>释放写锁时<ul>
<li>先通知所有读操作</li>
<li>将 readerCount 置为正数，释放写锁互斥锁</li>
</ul>
</li>
</ul>
<p>RWMutex 在 Mutex 上提供了额外的细粒度控制，能在读操作远远多于写操作时提升性能。</p>
<h2 id="sync-noCopy"><a href="#sync-noCopy" class="headerlink" title="sync.noCopy"></a>sync.noCopy</h2><p>sync.noCopy 是一个特殊的私有结构体，tools&#x2F;go&#x2F;analysis&#x2F;passes&#x2F;copylock 包中的分析器会在编译期间检查被拷贝的变量中<strong>是否包含 sync.noCopy</strong> 或者<strong>实现了 Lock 和 Unlock 方法</strong>，如果包含该结构体或者实现了对应的方法就会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go vet proc.go./prog.go:10:10: assignment copies lock value to yawg: sync.WaitGroup</span><br><span class="line">./prog.go:11:14: call of fmt.Println copies lock value: sync.WaitGroup</span><br><span class="line">./prog.go:11:18: call of fmt.Println copies lock value: sync.WaitGroupv</span><br></pre></td></tr></table></figure>

<h2 id="semaTable"><a href="#semaTable" class="headerlink" title="semaTable"></a>semaTable</h2><p>semaTable 存储了可供 g 使用的信号量，是大小为 251 的数组。每一个元素存储了一个平衡树的根，节点是 sudog 类型，在使用时需要一个记录信号量数值的变量 sema，根据它的地址映射到数组中的某个位置，找到对应的节点就找到对应信号的等待队列。</p>
<blockquote>
<p>channel 没有使用信号量，而是自己实现了一套排队逻辑</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;</span><br><span class="line">   lock  mutex</span><br><span class="line">   treap *sudog <span class="comment">// root of balanced tree of unique waiters.</span></span><br><span class="line">   nwait <span class="type">uint32</span> <span class="comment">// Number of waiters. Read w/o the lock.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>sync.once 文件内容很少，只有一个结构体与两个方法，其中 sync.Once 用于保证 go 程序运行期间的某段代码只执行一次，暴露出的 Do 方法用于执行给定的方法</p>
<blockquote>
<p>在以下代码中，只会输出一次 only once</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	o := &amp;sync.Once&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">only once</span><br></pre></td></tr></table></figure>

<p>Once 的结构体也很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">   done <span class="type">uint32</span> <span class="comment">// 标识代码块是否执行过done</span></span><br><span class="line">   m    Mutex  <span class="comment">// 互斥锁，用于保证原子性操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看 Do 方法的实现。在源代码的注释中说明了为什么不直接 CAS 设定值，if 方法中调用函数，而要使用这种方式，是因为<strong>Do 保证了当它返回时，f 函数已经完成，而直接 CAS 后成功执行不成功返回是无法这样保证的。对于 panic 而言，defer 保证了 panic 也会将 done 置为 1，因此即使 f 调用中 panic，依然算已经执行过。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do 调用函数 f 当且仅当 Do 为这个 Once 的实例第一次被调用时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">   <span class="comment">// fast path，快速判断是否已执行。如果未执行则进入slow path</span></span><br><span class="line">   <span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">      o.doSlow(f)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">   <span class="comment">// 加锁保证原子性操作</span></span><br><span class="line">   o.m.Lock()</span><br><span class="line">   <span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">   <span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// defer 保证了如果panic也能设置已完成</span></span><br><span class="line">      <span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">      f()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p>Cond 可以让一组 goroutine 在满足特定条件时被唤醒。在以下代码中同时运行了 11 个 goroutine，其中 10 个 goroutine 通过<code>sync.Cond.Wait()</code>等待特定条件瞒住，1 个 goroutine 通过<code>sync.Cond.Broadcast()</code>唤醒所有陷入等待的 goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">   <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> listen(c)</span><br><span class="line">   &#125;</span><br><span class="line">   time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">   <span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">   ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">   signal.Notify(ch, os.Interrupt)</span><br><span class="line">   &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">   c.L.Lock()</span><br><span class="line">   atomic.StoreInt64(&amp;status, <span class="number">1</span>)</span><br><span class="line">   c.Broadcast()</span><br><span class="line">   c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">   c.L.Lock()</span><br><span class="line">   <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123;</span><br><span class="line">      c.Wait()</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;listen&quot;</span>)</span><br><span class="line">   c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br><span class="line">listen</span><br></pre></td></tr></table></figure>

<p>结构体 sync.Cond 中包含了四个字段，最主要的还是 notify。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">   noCopy noCopy <span class="comment">// 保证结构体不会在编译期间内被拷贝</span></span><br><span class="line">   L Locker      <span class="comment">// 用于保护内部的notify字段</span></span><br><span class="line">   notify  notifyList  <span class="comment">// 一个goroutine链表，是实现同步机制的核心结构</span></span><br><span class="line">   checker copyChecker <span class="comment">// 禁止运行期间发生的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notifyList 维护了一个 goroutine 链表，以及不同状态的 goroutine 索引</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">   wait   <span class="type">uint32</span>            <span class="comment">// 正在等待的goroutine索引</span></span><br><span class="line">   notify <span class="type">uint32</span>            <span class="comment">// 已通知到的goroutine索引</span></span><br><span class="line">   lock   <span class="type">uintptr</span> <span class="comment">// key field of the mutex</span></span><br><span class="line">   head   unsafe.Pointer    <span class="comment">// 指向链表头节点</span></span><br><span class="line">   tail   unsafe.Pointer    <span class="comment">// 指向链表尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建一个 Cond 时，必须传入一个 mutex 以关联这个 Cond，保证这个 Cond 的同步属性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sync-Cond-Wait"><a href="#sync-Cond-Wait" class="headerlink" title="sync.Cond.Wait()"></a>sync.Cond.Wait()</h3><p><code>Wait()</code>会使得当前 goroutine 陷入休眠，执行过程分为两个步骤：</p>
<ol>
<li>调用<code>runtime_notifyListAdd()</code>将等待计数器 +1 并解锁</li>
<li>调用<code>runtime_notifyListWait()</code>等待其他 goroutine 的唤醒并加锁</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">   c.L.Unlock()</span><br><span class="line">   runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">   c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">   <span class="comment">// 即将wait以原子方式+1</span></span><br><span class="line">   <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>notifyListWait()</code>则将当前 goroutine 封装为 sudog，追加到 goroutine 通知链表的末尾，然后挂起当前 goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">   <span class="comment">// 如果已经被唤醒，直接返回</span></span><br><span class="line">   <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">      unlock(&amp;l.lock)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 封装为sudog，并入队</span></span><br><span class="line">   s := acquireSudog()</span><br><span class="line">   s.g = getg()</span><br><span class="line">   s.ticket = t</span><br><span class="line">   s.releasetime = <span class="number">0</span></span><br><span class="line">   t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">      t0 = cputicks()</span><br><span class="line">      s.releasetime = <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">      l.head = s</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l.tail.next = s</span><br><span class="line">   &#125;</span><br><span class="line">   l.tail = s</span><br><span class="line">   <span class="comment">// 挂起当前goroutine</span></span><br><span class="line">   <span class="comment">// 让出当前cpu，并等待scheduler唤醒</span></span><br><span class="line">   goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">      blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal()"></a>Signal()</h3><p><code>Signal()</code>会唤醒队列最前面的 goroutine，核心代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// fast path：如果在上次signal后，没有新的waiter，不需要锁了，直接返回即可</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="comment">// 在加锁的情况下recheck</span></span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">      unlock(&amp;l.lock)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 从头开始找到满足sudog.ticket == l.notify的goroutine，唤醒并返回</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">      <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">         n := s.next</span><br><span class="line">         <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            p.next = n</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l.head = n</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">            l.tail = p</span><br><span class="line">         &#125;</span><br><span class="line">         unlock(&amp;l.lock)</span><br><span class="line">         s.next = <span class="literal">nil</span></span><br><span class="line">         readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast()"></a>Broadcast()</h3><p><code>Broadcast()</code>会唤醒所有满足条件的 goroutine，这个唤醒顺序也是按照加入队列的先后顺序，先加入的会先被唤醒。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">   c.checker.check()</span><br><span class="line">   runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// fast path</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">   s := l.head</span><br><span class="line">   l.head = <span class="literal">nil</span></span><br><span class="line">   l.tail = <span class="literal">nil</span></span><br><span class="line">   atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">   <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">      next := s.next</span><br><span class="line">      s.next = <span class="literal">nil</span></span><br><span class="line">      readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">      s = next</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readyWithTime</span><span class="params">(s *sudog, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> s.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">      s.releasetime = cputicks()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Mark g ready to run.</span></span><br><span class="line">   goready(s.g, traceskip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在条件长时间无法满足时，与使用<code>for &#123;&#125;</code>的忙等相比，sync.Cond 能够让出处理器的使用权，提高 CPU 的利用率。</p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>Go 原生 map 不是线程安全的，在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志置位（等于 1），则直接 panic。而 sync.Map 则是并发安全的，读取、插入、删除都保持着常数级的时间复杂度，且 sync.Map 的零值是有效的，是一个空 map。sync.Map 更适用于读多写少的场景，写多的场景中会导致 read map 缓存失效，需要加锁，导致冲突增多，而且因为未命中 read map 次数变多，导致 dirty map 提升为 read map，是一个 O(N) 的操作，会降低性能。</p>
<p>一般解决并发读写 map 的思路是加一把大锁，在读写的时候先进行加锁，或把一个 map 分成若干个小 map，对 key 进行哈希操作，只操作对应的小 map，前者锁粒度大，影响并发性能，而后者实现较为复杂，容易出错。</p>
<p>与原生 map 相比，sync.Map 仅遍历的方式有些不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> m sync.Map</span><br><span class="line">   <span class="comment">// 存放</span></span><br><span class="line">   m.Store(<span class="string">&quot;test1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">   m.Store(<span class="string">&quot;test2&quot;</span>, <span class="number">2</span>)</span><br><span class="line">   <span class="comment">// 取值</span></span><br><span class="line">   age, _ := m.Load(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">   fmt.Println(age)</span><br><span class="line">   <span class="comment">// 遍历</span></span><br><span class="line">   m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      name := key.(<span class="type">string</span>)</span><br><span class="line">      age := value.(<span class="type">int</span>)</span><br><span class="line">      fmt.Println(name, age)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 删除</span></span><br><span class="line">   m.Delete(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">   age, ok := m.Load(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">   fmt.Println(age, ok)</span><br><span class="line">   <span class="comment">// 读取或写入</span></span><br><span class="line">   m.LoadOrStore(<span class="string">&quot;test2&quot;</span>, <span class="number">3</span>)</span><br><span class="line">   age, _ = m.Load(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">   fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">test2 2    </span><br><span class="line">test1 1    </span><br><span class="line">&lt;nil&gt; <span class="literal">false</span></span><br><span class="line">2 </span><br></pre></td></tr></table></figure>

<h3 id="sync-Map-的底层实现"><a href="#sync-Map-的底层实现" class="headerlink" title="sync.Map 的底层实现"></a>sync.Map 的底层实现</h3><p>由四个字段组成，其中 mu 互斥锁用于保护 read 和 dirty 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu Mutex</span><br><span class="line">   read atomic.Value <span class="comment">// 实际上存储的是readOnly，可以并发读</span></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry <span class="comment">// 原生map，包含新写入的key，且包含read中所有被删除的key</span></span><br><span class="line">   misses <span class="type">int</span> <span class="comment">// 每次从read中读取失败就会自增misses，达到一定阈值后会将dirt提升为read</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正存储key&#x2F;value的是read与dirty，但是它们存储的方式是不一样的，前者用atomic.Value，后者单纯使用原生map，原因是read用的是无锁操作，需要保证load&#x2F;store的原子性，而dirty map 的 load+store 操作是由 mu 互斥锁来保护的。</p>
<p>readOnly 是一个支持原子性的存储的只读数据结构，底层也是一个原生 map。其中 entry 包含了一个指针，指向 value。dirty 的 value 也是 entry 类型的，这里可以看出 read 和 dirty 各自维护了一套 key，key 指向的是同一个 value，只要修改了 entry，对 read 和 dirty 都是可见的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">   m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">   amended <span class="type">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">   p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/img10.png" alt="img"></p>
<p>entry 的指针 p 共有三种状态：</p>
<ol>
<li>p &#x3D;&#x3D; nil：说明该 key&#x2F;value 已被删除，且 m.dirty &#x3D;&#x3D; nil 或 m.dirty[k]指向该 key</li>
<li>p &#x3D;&#x3D; expunged，说该 key&#x2F;value 已被删除，且 m.dirty 不为 nil，且 m.dirty 中没有这个 key</li>
<li>p 指向一个正常值：表示实际 interface{}的地址，且被记录在 m.read.m[key]中，如果此时 m.dirty 也不为 nil，那么它也被记录在 m.dirty[key]中，二者指向同一个地址。</li>
</ol>
<p>当删除 key 时，sync.Map 并不会真正地删除 key，而是通过 CAS 将 entry 的 p 设置为 nil，标记为被删除。如果之后创建 m.dirty，p 又会 CAS 设置为 expunged，且不会复制到 m.dirty 中。</p>
<p>如果 p 不为 expunged，和 entry 关联的 value 则可以被原子地更新，如果 p 为 expunged，那么只有在它初次被设置到 m.dirty 后才能被更新。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store()"></a>Store()</h3><p>expunged 实际上是一个指向任意类型的指针，用于标记从 dirty map 中删除的 entry。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(any))</span><br></pre></td></tr></table></figure>

<p>Store 直接看代码即可，如果 key 在 read 中，会先调用 tryStore，使用 for 循环+CAS 尝试更新 entry，如果更新成功则直接返回。接下来要么 read 中没有这个 key，要么 key 被标记为已删除了，需要先加锁再操作。</p>
<ol>
<li>先去 read 中 double check 下，如果存在 key，但 p 为 expunged，说明 m.dirty 不为 nil，且 m.dirty 不存在该 key。此时将 p 状态设置为 nil，将 key 插入 dirty map 中，更新对应 value</li>
<li>如果 read 中没有此 key，而 dirty 中有，直接更新对应 value</li>
<li>如果 read 和 dirty 都没有该 key，先看看 dirty 是否为空，为空就要创建一个 dirty，并从 read 中复制没被删除的元素。然后更新 amended 标记为 true，<strong>标识 dirty 中存在 read 没有的 key</strong>，将 key&#x2F;value 写入 dirty map 中。更新对应的 value。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">   <span class="comment">// 如果read map中存在该key，则尝试直接修改</span></span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()</span><br><span class="line">   read, _ = m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">      <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">         <span class="comment">// 如果read map中存在该key，但p为expunged，说明m.dirty不为nil且m.dirty不存在该key</span></span><br><span class="line">         <span class="comment">// 此时将p的状态修改为nil，并在dirty map中插入key</span></span><br><span class="line">         m.dirty[key] = e</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新p指向value</span></span><br><span class="line">      e.storeLocked(&amp;value)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">      <span class="comment">// 如果read中不存在该key，但dirty map中存在该key，直接写入更新entry</span></span><br><span class="line">      <span class="comment">// 此时read map中仍然没有该key</span></span><br><span class="line">      e.storeLocked(&amp;value)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// read和dirty中都没有该key</span></span><br><span class="line">      <span class="comment">// 如果dirty map为nil，需要创建dirty map，并从read map中复制未删除的元素到新创建的dirty map中</span></span><br><span class="line">      <span class="comment">// 更新emended字段未true，表示dirty map中存在read map中没有的key</span></span><br><span class="line">      <span class="comment">// 将key/value写入dirty map</span></span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">         <span class="comment">// 添加第一个新key到dirty map中</span></span><br><span class="line">         <span class="comment">// 此处先判断dirty map是否为空，若为空，则浅拷贝read map一次</span></span><br><span class="line">         m.dirtyLocked()</span><br><span class="line">         m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)</span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为空，则创建一个dirty map，并从read map中复制未删除的元素到新创建的dirty map中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">   <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">         m.dirty[k] = e</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS设置entry，当p为expunged时返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *any) <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保entry没有被标记为已清除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Load"><a href="#Load" class="headerlink" title="Load()"></a>Load()</h3><p>流程比 Store 更简单。先从 read 中找，找到了直接调用<code>entry.load()</code>，否则看看 amended，如果是 false，说明 dirty 为空，直接返回 nil 和 false，如果 emended 为 true，说明 dirty 中可能存在要找的 key。先上锁，然后 double check 从 read 找，还没找到就去 dirty 中找，不管 dirty 中找没找到，都得在 missed 记一下，在 dirty 被提升为 read 前都会走这条路。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   e, ok := read.m[key]</span><br><span class="line">   <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      m.mu.Lock()</span><br><span class="line">      read, _ = m.read.Load().(readOnly)</span><br><span class="line">      e, ok = read.m[key]</span><br><span class="line">      <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">         e, ok = m.dirty[key]</span><br><span class="line">         m.missLocked()</span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>missLocked 直接将 misses+1，标识有一次未命中，如果未命中的次数小于 m.dirty 长度，直接返回，否则将 m.dirty 提升为 read，并清空 dirty 和 misses 计数。这样之前一段时间加的 key 就会进到 read 中，提高 read 的命中率。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">   m.misses++</span><br><span class="line">   <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">   m.dirty = <span class="literal">nil</span></span><br><span class="line">   m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>entry.load()</code>对 p 为 nil 和 p 为 expunged 的 entry 直接返回 nil 和 false，否则将其转为 interface{}返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">   <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete()"></a>Delete()</h3><p>套路与<code>Load()</code>和<code>Store()</code>相似，从 read 中查是否有这个 key，如果有的话调用<code>entry.delete()</code>，将 p 置为 nil。read 中没找到的话，如果 dirty 不为 nil，就去 dirty 中找，先上锁，再 double check，还没在 read 中找到就去 dirty 中找，然后执行删除操作，再调用 missLocked 看看是否要将 dirty 上升到 read，这里不管是否在 dirty 中找到都得标记一下 misses。如果找到并删除了，调用<code>entry.delete()</code>，否则返回 nil 和 false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">   m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   e, ok := read.m[key]</span><br><span class="line">   <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">      m.mu.Lock()</span><br><span class="line">      read, _ = m.read.Load().(readOnly)</span><br><span class="line">      e, ok = read.m[key]</span><br><span class="line">      <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">         e, ok = m.dirty[key]</span><br><span class="line">         <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">         <span class="comment">// 不管是否存在都记一下misses</span></span><br><span class="line">         m.missLocked()</span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>entry.delete()</code>也是 CAS 操作，将 p 置为 nil，当判断 p 为 nil 或 expunged 时会直接返回 nil 和 false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">      <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 read 中找到了 key，仅仅是将 p 置为 nil 做一个标记，这样在仅有 dirty 中有这个 key 的时候才会直接删除这个 key。这样的目的在于在下次查找这个 key 时会命中 read，提升效率，如果只在 dirty 存在，read 就无法起到缓存的作用，会直接删除。key 本身是需要在 missLocked 前将 key 从 dirty 中删除，才能使其被垃圾回收。</p>
<h3 id="LoadOrStore"><a href="#LoadOrStore" class="headerlink" title="LoadOrStore()"></a>LoadOrStore()</h3><p>结合了 Load 和 Store 的功能，如果 map 存在该 key，就返回对应 value，否则将 value 设置给该 key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value any) (actual any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">   <span class="comment">// fast path</span></span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">      actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">      <span class="keyword">if</span> ok &#123;</span><br><span class="line">         <span class="keyword">return</span> actual, loaded</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   m.mu.Lock()</span><br><span class="line">   <span class="comment">// 与store类似</span></span><br><span class="line">   read, _ = m.read.Load().(readOnly)</span><br><span class="line">   <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">      <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">         m.dirty[key] = e</span><br><span class="line">      &#125;</span><br><span class="line">      actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">      actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">      m.missLocked()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">         <span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">         <span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">         m.dirtyLocked()</span><br><span class="line">         m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      m.dirty[key] = newEntry(value)</span><br><span class="line">      actual, loaded = value, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryLoadOrStore(i any) (actual any, loaded, ok <span class="type">bool</span>) &#123;</span><br><span class="line">   p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">   <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   ic := i</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, unsafe.Pointer(&amp;ic)) &#123;</span><br><span class="line">         <span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">      <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range()"></a>Range()</h3><p>参数需要传入一个函数，<code>Range()</code>在遍历时会将调用时刻所有key&#x2F;value传给该函数，如果返回了false会停止遍历。由于会遍历所有key，是一个O(N)的操作，所以将dirty提升为read，将开销分摊开，提升了效率。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value any)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">   read, _ := m.read.Load().(readOnly)</span><br><span class="line">   <span class="comment">// dirty存在read没有的key</span></span><br><span class="line">   <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">      m.mu.Lock()</span><br><span class="line">      read, _ = m.read.Load().(readOnly)</span><br><span class="line">      <span class="comment">// double check</span></span><br><span class="line">      <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">         <span class="comment">// 将dirty提升为read</span></span><br><span class="line">         read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">         m.read.Store(read)</span><br><span class="line">         m.dirty = <span class="literal">nil</span></span><br><span class="line">         m.misses = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// O(N)遍历，当f返回false时停止</span></span><br><span class="line">   <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">      v, ok := e.load()</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">Go 语言并发编程、同步原语与锁</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/416">多图详解 Go 的 sync.Pool 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10">What’s false sharing and how to solve it (using Golang as example)</a></li>
<li><a target="_blank" rel="noopener" href="https://morsmachine.dk/go-scheduler">The Go scheduler - Morsing’s blog</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/429">Go 中由 WaitGroup 引发对内存对齐思考</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6981366395699200014">[Golang]从 sync.waitGroup 看内存对齐 - 掘金</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://makonike.github.io">谈笑风生间</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://makonike.github.io/2023/01/29/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Sync%E6%A0%87%E5%87%86%E5%BA%93/">https://makonike.github.io/2023/01/29/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Sync%E6%A0%87%E5%87%86%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://makonike.github.io" target="_blank">谈笑风生间</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E6%A0%87%E5%87%86%E5%BA%93/">标准库</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="post-meta__tags" href="/tags/sync/">sync</a></div><div class="post_share"><div class="social-share" data-image="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyansyncbiaozhuenku/title.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/01/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" title="一文了解一致性哈希"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojieyizhixinghaxi/78296349_p0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一文了解一致性哈希</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/12/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80HTTP%E6%A0%87%E5%87%86%E5%BA%93/" title="一文了解 Go 语言 HTTP 标准库"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyanhttpbiaozhuenku/title.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一文了解 Go 语言 HTTP 标准库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/12/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80HTTP%E6%A0%87%E5%87%86%E5%BA%93/" title="一文了解 Go 语言 HTTP 标准库"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiegoyuyanhttpbiaozhuenku/title.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-12</div><div class="title">一文了解 Go 语言 HTTP 标准库</div></div></a></div><div><a href="/2023/08/31/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Context%E6%A0%87%E5%87%86%E5%BA%93/" title="一文了解 Go 语言 Context 标准库"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/shenrujiedugocontext/title.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">一文了解 Go 语言 Context 标准库</div></div></a></div><div><a href="/2023/05/06/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3WebSocket%E5%8D%8F%E8%AE%AE/" title="一文了解 WebSocket 协议"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiewebsocket/title.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-06</div><div class="title">一文了解 WebSocket 协议</div></div></a></div><div><a href="/2023/07/23/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/" title="初探容器网络"><img class="cover" src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/chutanrongqiwangluo/title.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-23</div><div class="title">初探容器网络</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/title/avatar1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">谈笑风生间</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Makonike"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Makonike" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:makonike@anyview.fun" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">技术改变世界~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-WaitGroup"><span class="toc-number">2.</span> <span class="toc-text">sync.WaitGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup"><span class="toc-number">2.1.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wait"><span class="toc-number">2.2.</span> <span class="toc-text">Wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add"><span class="toc-number">2.3.</span> <span class="toc-text">Add()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">WaitGroup 的实现原理总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Pool"><span class="toc-number">3.</span> <span class="toc-text">sync.Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89-sync-Pool"><span class="toc-number">3.1.</span> <span class="toc-text">如果没有 sync.Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-Pool-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">sync.Pool 的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poolLocal"><span class="toc-number">3.3.</span> <span class="toc-text">poolLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poolChain"><span class="toc-number">3.4.</span> <span class="toc-text">poolChain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1-Get"><span class="toc-number">3.5.</span> <span class="toc-text">获取一个对象-Get()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pin"><span class="toc-number">3.5.1.</span> <span class="toc-text">pin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popHead"><span class="toc-number">3.5.2.</span> <span class="toc-text">popHead()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getSlow"><span class="toc-number">3.5.3.</span> <span class="toc-text">getSlow()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popTail"><span class="toc-number">3.5.4.</span> <span class="toc-text">popTail()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1-Put"><span class="toc-number">3.6.</span> <span class="toc-text">存放一个对象-Put()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pushHead"><span class="toc-number">3.6.1.</span> <span class="toc-text">pushHead()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pack"><span class="toc-number">3.6.2.</span> <span class="toc-text">pack()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-number">3.7.</span> <span class="toc-text">GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Mutex"><span class="toc-number">4.</span> <span class="toc-text">sync.Mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">Mutex 的实现原理总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-RWMutex"><span class="toc-number">5.</span> <span class="toc-text">sync.RWMutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E4%B8%8E-UnLock"><span class="toc-number">5.1.</span> <span class="toc-text">Lock 与 UnLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RLock-%E4%B8%8E-RUnlock"><span class="toc-number">5.2.</span> <span class="toc-text">RLock 与 RUnlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-Mutex"><span class="toc-number">5.3.</span> <span class="toc-text">与 Mutex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-noCopy"><span class="toc-number">6.</span> <span class="toc-text">sync.noCopy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaTable"><span class="toc-number">7.</span> <span class="toc-text">semaTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Once"><span class="toc-number">8.</span> <span class="toc-text">sync.Once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Cond"><span class="toc-number">9.</span> <span class="toc-text">sync.Cond</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-Cond-Wait"><span class="toc-number">9.1.</span> <span class="toc-text">sync.Cond.Wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Signal"><span class="toc-number">9.2.</span> <span class="toc-text">Signal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Broadcast"><span class="toc-number">9.3.</span> <span class="toc-text">Broadcast()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Map"><span class="toc-number">10.</span> <span class="toc-text">sync.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-Map-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.1.</span> <span class="toc-text">sync.Map 的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store"><span class="toc-number">10.2.</span> <span class="toc-text">Store()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load"><span class="toc-number">10.3.</span> <span class="toc-text">Load()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete"><span class="toc-number">10.4.</span> <span class="toc-text">Delete()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadOrStore"><span class="toc-number">10.5.</span> <span class="toc-text">LoadOrStore()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range"><span class="toc-number">10.6.</span> <span class="toc-text">Range()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">11.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/28/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%9A%E6%88%90%E9%95%BF%E3%80%81%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%B2%9F%E9%80%9A/" title="2023 年度总结：成长、探索与沟通"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/2023-zongjie/title4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023 年度总结：成长、探索与沟通"/></a><div class="content"><a class="title" href="/2023/12/28/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%EF%BC%9A%E6%88%90%E9%95%BF%E3%80%81%E6%8E%A2%E7%B4%A2%E4%B8%8E%E6%B2%9F%E9%80%9A/" title="2023 年度总结：成长、探索与沟通">2023 年度总结：成长、探索与沟通</a><time datetime="2023-12-28T15:17:47.000Z" title="发表于 2023-12-28 23:17:47">2023-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/11/Hello%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" title="Hello 算法之十大排序"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/hellosuanfazhishidapaixv/title.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello 算法之十大排序"/></a><div class="content"><a class="title" href="/2023/09/11/Hello%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" title="Hello 算法之十大排序">Hello 算法之十大排序</a><time datetime="2023-09-11T08:31:43.000Z" title="发表于 2023-09-11 16:31:43">2023-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/31/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Context%E6%A0%87%E5%87%86%E5%BA%93/" title="一文了解 Go 语言 Context 标准库"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/shenrujiedugocontext/title.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文了解 Go 语言 Context 标准库"/></a><div class="content"><a class="title" href="/2023/08/31/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80Context%E6%A0%87%E5%87%86%E5%BA%93/" title="一文了解 Go 语言 Context 标准库">一文了解 Go 语言 Context 标准库</a><time datetime="2023-08-31T08:25:35.000Z" title="发表于 2023-08-31 16:25:35">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/24/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B/" title="一文了解权限访问控制模型"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/yiwenliaojiequanxianfangwenkongzhimoxing/20230824184449.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文了解权限访问控制模型"/></a><div class="content"><a class="title" href="/2023/08/24/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B/" title="一文了解权限访问控制模型">一文了解权限访问控制模型</a><time datetime="2023-08-24T10:37:34.000Z" title="发表于 2023-08-24 18:37:34">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/23/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/" title="初探容器网络"><img src="https://makonike-blog.oss-cn-guangzhou.aliyuncs.com/blog/chutanrongqiwangluo/title.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="初探容器网络"/></a><div class="content"><a class="title" href="/2023/07/23/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/" title="初探容器网络">初探容器网络</a><time datetime="2023-07-23T10:44:45.000Z" title="发表于 2023-07-23 18:44:45">2023-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 谈笑风生间</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20227404" target="_blank">萌ICP备20227404号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ab290a3326f66d6459f3',
      clientSecret: 'f9bba6ea9384cf5bcaadc0178dce4a1cccfa3b4a',
      repo: 'makonike.github.io',
      owner: 'Makonike',
      admin: ['Makonike'],
      id: 'd1e4f9a36c3df9dea595bce916dfe849',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer src="/_vercel/insights/script.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>